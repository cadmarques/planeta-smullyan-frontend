<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Detalhes do Puzzle</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="assets/styles.css">
  <script>
    // Configuração de URLs dinâmicas
    const API_BASE_URL = window.location.hostname === 'localhost' 
        ? 'http://localhost:5000' 
        : 'https://planeta-smullyan-backend.onrender.com'; // Substitua pela URL do backend no Render

    const FRONTEND_BASE_URL = window.location.hostname === 'localhost' 
        ? 'http://localhost:3000' 
        : 'https://cadmarques.github.io/planeta-smullyan-frontend'; // Substitua pela URL do GitHub Pages
  </script>
</head>
<body>
  <div class="container text-center mt-5">
    <!-- Banner da Ilha -->
    <div id="island-banner" class="mb-4 d-flex justify-content-center">
      <img id="banner-image" src="" alt="Banner da Ilha" class="img-fluid rounded" style="max-height: 300px;">
    </div>

    <!-- Título e Descrição da Ilha -->
    <h1 id="island-name">Carregando...</h1>
    <p id="island-description" class="lead">Descrição da ilha.</p>

    <!-- Detalhes do Puzzle -->
    <div id="puzzle-details" class="mt-4">
      <h2 id="puzzle-title">Carregando...</h2>
      <div id="puzzle-steps">
        <h3>Passo <span id="current-step">1</span> de <span id="total-steps"></span></h3>
        <div id="step-content">
          <!-- Conteúdo do passo será carregado aqui -->
        </div>
        <div class="d-flex justify-content-between mt-3">
          <button id="prev-step" class="btn btn-secondary" disabled>Voltar</button>
          <button id="next-step" class="btn btn-primary">Avançar</button>
        </div>
      </div>
    </div>

    <!-- Botão para Voltar à Página da Ilha -->
    <a id="back-to-island" href="island" class="btn btn-secondary btn-lg mt-4">Voltar à Ilha</a>
  </div>

  <script>
    // Variáveis globais
    let currentStepIndex = 0;
    let steps = [];
    const BASE_URL = `${API_BASE_URL}`; // URL base do backend

    // Função para carregar um passo específico
    function loadStep(index) {
        const step = steps[index];
        const stepContent = document.getElementById('step-content');
        stepContent.innerHTML = ''; // Limpa o conteúdo anterior

        // Verificar se há uma referência a personagens de outro passo
        let charactersToDisplay = [];
        if (step.charactersRef !== undefined && step.charactersRef !== null) {
          // Buscar os personagens do passo referencia
          console.log("entrou no characters to dispplay...");
          charactersToDisplay = steps[step.charactersRef-1].characters || [];
          console.log(charactersToDisplay);
        } else {
          // Usar os personagens do passo atual
          charactersToDisplay = step.characters || [];
        }

        // Exibir personagens (se houver)
        //if (step.characters && step.characters.length > 0) {
        if (charactersToDisplay.length > 0) {
          const charactersDiv = document.createElement('div');
          charactersDiv.className = 'mb-3'; // Contêiner principal para todos os personagens

          let currentLine = null; // Variável para rastrear a linha atual
          let lastPosition = null; // Variável para rastrear o último alinhamento

          charactersToDisplay.forEach(character => {
            // Verificar se o alinhamento mudou
            if (lastPosition !== character.position) {
              // Criar uma nova linha
              currentLine = document.createElement('div');
              currentLine.className = `d-flex ${character.position === 'left' ? 'justify-content-start' : 'justify-content-end'} mb-2`;
              charactersDiv.appendChild(currentLine);
              lastPosition = character.position; // Atualizar o último alinhamento
            }

            // Criar o elemento do personagem
            const characterElement = document.createElement('div');
            characterElement.className = 'text-center me-3'; // Margem entre personagens

            // Construir a URL da imagem
            const imageUrl = `${BASE_URL}${character.image.url}`;

            // Criar elemento de imagem
            characterElement.innerHTML = `
              <img src="${imageUrl}" alt="${character.label || ''}" width="100" class="rounded-circle">
              <div>${character.label || ''}</div>
            `;

            // Adicionar o personagem à linha atual
            currentLine.appendChild(characterElement);
          });

          // Adicionar o contêiner principal ao conteúdo do passo
          stepContent.appendChild(charactersDiv);
        }
        /*if (step.characters && step.characters.length > 0) {
            const charactersDiv = document.createElement('div');
            charactersDiv.className = 'd-flex justify-content-center mb-3';
            step.characters.forEach(character => {
            const characterElement = document.createElement('div');
            characterElement.className = `text-center ${character.position === 'left' ? 'me-3' : 'ms-3'}`;

            // Construir a URL da imagem
            const imageUrl = `${BASE_URL}${character.image.url}`; // Usa o campo url do modelo Image

            // Criar elemento de imagem
            characterElement.innerHTML = `
                <img src="${imageUrl}" alt="${character.label || ''}" width="100" class="rounded-circle">
                <div>${character.label || ''}</div>
            `;
            charactersDiv.appendChild(characterElement);
            });
            stepContent.appendChild(charactersDiv);
        }*/

        // Exibir texto principal
        const bodyElement = document.createElement('p');
        bodyElement.classList.add('text-content'); // Adiciona a classe "text-content"
        bodyElement.textContent = step.body;
        stepContent.appendChild(bodyElement);

        // Atualizar botões de navegação
        document.getElementById('current-step').textContent = index + 1;
        document.getElementById('prev-step').disabled = index === 0;
        document.getElementById('next-step').disabled = index === steps.length - 1;
    }

    // Obter o ID da ilha e do puzzle da URL
    const urlParams = new URLSearchParams(window.location.search);
    const islandId = urlParams.get('islandId');
    const puzzleId = urlParams.get('puzzleId');

    if (!islandId || !puzzleId) {
      console.error('ID da ilha ou do puzzle não encontrado na URL.');
    } else {
      console.log(`Buscando dados da ilha em: /api/islands/${islandId}`);
      console.log(`Buscando dados do puzzle em: /api/puzzle-details/${puzzleId}`);
      // Configurar o botão "Voltar à Ilha"
      const backButton = document.getElementById('back-to-island');
      if (backButton) {
        backButton.href = `island?id=${islandId}`;
        console.log(`Botão 'Voltar à Ilha' configurado com islandId: ${islandId}`);
      }

      // Buscar os dados da ilha do backend
      fetch(`${API_BASE_URL}/api/islands/${islandId}`)
        .then(response => {
        if (!response.ok) {
            throw new Error('Erro ao carregar a ilha.');
        }
        return response.json();
        })
        .then(islandData => {
        // Preencher o banner, título e descrição da ilha
        const bannerImage = document.getElementById('banner-image');
        if (islandData.banner && islandData.banner.url) {
            bannerImage.src = `${API_BASE_URL}${islandData.banner.url}`;
            bannerImage.style.display = 'block';
        } else {
            bannerImage.style.display = 'none'; // Oculta o banner se não houver
        }

        document.getElementById('island-name').textContent = islandData.name;
        document.getElementById('island-description').classList.add('text-content'); // Adiciona a classe "text-content"
        document.getElementById('island-description').textContent = islandData.description;

        // Buscar os dados do puzzle do backend
        return fetch(`${API_BASE_URL}/api/puzzle-details/${puzzleId}`);
        })
        .then(response => {
        if (!response.ok) {
            throw new Error('Erro ao carregar o puzzle.');
        }
        return response.json();
        })
        .then(puzzleData => {
        // Preencher os detalhes do puzzle
        document.getElementById('puzzle-title').textContent = puzzleData.title;

        // Verificar se o campo steps existe
        if (puzzleData.steps && puzzleData.steps.length > 0) {
            steps = puzzleData.steps;
            document.getElementById('total-steps').textContent = steps.length;
            loadStep(currentStepIndex); // Carrega o primeiro passo
        } else {
            console.error('Erro: Os passos do puzzle não foram encontrados.');
            document.getElementById('step-content').innerHTML = '<p>Não há passos disponíveis para este puzzle.</p>';
        }
        })
        .catch(error => {
        console.error('Erro ao carregar os dados:', error);
        });
    }

    // Botão "Voltar"
    document.getElementById('prev-step').addEventListener('click', () => {
      if (currentStepIndex > 0) {
        currentStepIndex--;
        loadStep(currentStepIndex);
      }
    });

    // Botão "Avançar"
    document.getElementById('next-step').addEventListener('click', () => {
      if (currentStepIndex < steps.length - 1) {
        currentStepIndex++;
        loadStep(currentStepIndex);
      }
    });
  </script>
</body>
</html>